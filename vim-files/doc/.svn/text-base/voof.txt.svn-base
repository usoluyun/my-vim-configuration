*voof.txt*      VOOF (Vim Outliner Of Folds)
VOOF (Vim Outliner Of Folds): two-pane outliner and related utilities
plugin for Python-enabled Vim version 7.x
Website: http://www.vim.org/scripts/script.php?script_id=2657
 Author: Vlad Irnov  (vlad DOT irnov AT gmail DOT com)
License: This documentaion is released under the Do What The Fuck You Want To
         Public License, verions 2. See http://sam.zoy.org/wtfpl/COPYING.
Version: 1.9, 2009-12-19

==============================================================================
Contents   [[[1~
  Overview                         |voof_overview|
  Requirements                     |voof_requirements|
  Installation                     |voof_install|
  Options                          |voof_options|
  ALL MAPPINGS & COMMANDS          |voof_map|
  OUTLINING (:Voof)                |voof_Voof|
  EXECUTING NODES (:Voofexec)      |voof_Voofexec|
  __PyLog__ BUFFER (:Vooflog)      |voof_Vooflog|
  Implementation notes             |voof_notes|

==============================================================================
Overview   [[[1~
                                                 *voof_overview*
VOOF (Vim Outliner Of Folds) is a plugin for Vim that emulates a two-pane text
outliner. It can be used with any Vim buffer that has start fold markers with
level numbers (|fold-marker|) such as in this help file. The only requirement
is that there are should be no end fold markers with levels.

Screenshots and an animation: http://www.flickr.com/photos/voof/

There are four main Ex commands: Voof, Voofhelp, Voofexec, Vooflog.

:Voof       Create outline of the current buffer. The outline is constructed
            from lines with start fold markers with level numbers, which
            become headlines. The outline is displayed in a separate window
            with a scratch buffer, which emulates the tree pane of a two-pane
            outliner. Such buffers are referred to as Tree buffers. The
            current buffer becomes a Body buffer. Each Tree headline is
            associated with a region (usually a fold) of the corresponding
            Body, called node. Nodes can be navigated by browsing the Tree.
            They can also be manipulated from the Tree: moved up/down,
            promoted/demoted, marked/unmarked, etc.
            See OUTLINING (|voof_Voof|) for detailed user guide.

                                                 *voof_Voofhelp*
:Voofhelp   Open help file voof.txt as outline in a new tabpage. If voof.txt
            is installs via |helptags|, the file is opened as Vim help file
            (:tab help voof.txt) so that all tags will be active.


The VOOF plugin also provides two utilities useful when working with Vim and
Python scripts. They can be used independently of the outlining functionality
provided by the command :Voof. These utilities attempt to emulate
corresponding features of Leo text outliner.

:Voofexec   Execute text in the current node or fold as Vim script or Python
            script. This is useful for testing code snippets and for
            organizing scripts by segregating them into folds. This command
            does not require an outline to be created and can be used with any
            buffer that has folds.
            See EXECUTING SCRIPTS (|voof_Voofexec|) for details.

:Vooflog    Create scratch buffer __PyLog__ and redirect Python stdout and
            stderr to that buffer. This is useful when developing Python
            scripts and when scripting Vim with Python. This feature is not
            related to folding or outlining and is completely independent from
            the rest of the plugin.
            See __PyLog__ BUFFER (|voof_Vooflog|) for details.

==============================================================================
QUICK DEMO (no installation needed)   [[[2~
Extract VOOF archive to any folder. Open "plugin/voof.vim" in Vim, and do >
    :so %
    :Voof
This will create Tree buffer for voof.vim, which will become a Body buffer.

All VOOF mappings, except Return and Tab, are for Tree buffers only.

<Up>, <Down>, <Left>, <Right> arrow keys move around the Tree and select new
node (Normal mode).

<Return> selects node under the cursor and then cycles between Tree and Body.
So, to select another node, move to it with h, j, etc. and hit Return.

<Tab> cycles between Tree and Body windows without selecting node.

<Space> expands/contracts node without selecting it. Standard Vim folding
command (zo, zc, zR, zM, etc.) can be used as well.

Left mouse click in the Tree selects node. If the click is outside of the
headline text, the node's expanded/contracted status is toggled.

Edit a headline (line with a start fold marker) in voof.vim and go back into
the Tree: the outline will be updated.

<C-Up>, <C-Down> move node or a range of sibling nodes up/down.
<C-Left>, <C-Right> promote/demote.

Execute the command :Voofhelp to see all commands and mappings.

To create outline for another buffer, execute the command :Voof for it: >
    :tab h netrw
    :Voof
Folder "voof_samples" contains some outlines to experiment with.
File "calendar_outline.txt" is a rather large outline for stress-testing
purposes: 3.1MB, 56527 lines, 4160 headlines.

To try Python Log Buffer feature: >
    :Voofl
    :py assert 2==3
    :py print VOOF.nodes
    :py print u'\u2248 \u2260'

==============================================================================
Limitations   [[[2~
Voof is not scalable to large outlines. Nodes are not true object, they are
just line numbers of Body headlines. The bottleneck is the brute force update
of the outline data (performed by voof.voofUpdate()). Such update, which
basically recreates outline from scratch, must be done whenever the user
switches to Tree buffer after modifying corresponding Body--we can't possibly
know what the user did with the Body while he was away from the Tree.

Sample outline "calendar_outline.txt" seems to be approaching the usable size
limit on my 2002 notebook (1.6GHz Pentium 4 Mobile):
    3.2MB, 56527 lines, 4160 headlines.
When moving to Tree after modifying Body, the pause due to outline update is
noticeable but is still less than a second.

Browsing outline is fast regardless of it's size. Outline operations are also
fast because they bypass global outline update unless "g:voof_verify_oop" is
set to 1.

In case of "calendar_outline.txt" stress test, the time consuming step is not
just scanning for fold markers, but also comparing >4000 headlines between the
old and new outlines, or, if outlines are very different, setting all lines in
the Tree buffer. This means that even larger files can be outlined if they
have much fewer headlines.

==============================================================================
Other Text Outliners  [[[2~

Leo:
    http://webpages.charter.net/edreamleo/front.html
    The __PyLog__ buffer, which is created by the command :Vooflog, is the
    equivalent of Leo's log pane.
    The :Voofexec command is like Leo's Execute Script command when performed
    on a node which has an @others directive.
    Mark/Unmark nodes operations are modeled after identical Leo commands.

The "Tag List" Vim plugin:
    http://vim.sourceforge.net/scripts/script.php?script_id=273
    VOOF is conceptually similar to the Tag List plugin and other code
    browsers. Tag List uses the ctags program to scan file for lines with
    tags. VOOF uses Python script to scan buffer for lines with start fold
    markers with levels.

Vim command :vimgrep can be used to create an outline of current buffer: >
    :vimgrep /{{{/j %
    :copen

VO, Vim Outliner:
    http://www.vimoutliner.org/
TVO, The Vim Outliner:
    http://vim.sourceforge.net/scripts/script.php?script_id=517

Various Vim scripts with outlining-like functionality (there are probably many
other):
TaskList.vim : Eclipse like task list:
    http://www.vim.org/scripts/script.php?script_id=2607
DotOutlineTree:
    http://www.vim.org/scripts/script.php?script_id=1225
calendar.vim : Calendar
    http://www.vim.org/scripts/script.php?script_id=52


Code Browser:
    http://code-browser.sourceforge.net/

Emacs oultining modes, OrgMode seems to be popular:
    http://www.emacswiki.org/emacs/CategoryOutline

Listings of outliner programs:
    http://www.marktaw.com/reviews/Outliners.html
    http://www.outlinersoftware.com/topics/viewt/807/0/list-of-outliners
    http://en.wikipedia.org/wiki/Category:Outliners


==============================================================================
Requirements   [[[1~
                                                 *voof_requirements*
VOOF uses Python and requires Python-enabled Vim 7.x, that is Vim compiled
with the Python interface. Your Vim is Python-enabled if it can do >
    :py print 2**0.5

Python version should be 2.4 - 2.6 .
Python 3 is not supported and is not compatible with Vim anyway.

Vim version 7.2 or above is preferred. Version 7.1 should also work.
Version 7.0 might work as well but has not been tested.

Vim should be compiled using normal or bigger feature set.

Vim patch 7.2.161 is required in order to be able to work on the same outline
(or any buffer with folds) in separate tabpages.

==============================================================================
Installation   [[[1~
                                                 *voof_install*
Copy "plugin/voof.vim" and "plugin/voof.py" to the local plugin folder: >
    $HOME/vimfiles/plugin (Windows)
    ~/.vim/plugin         (Unix)
Copy "doc/voof.txt" to the local doc folder. >
    $HOME/vimfiles/doc    (Windows)
    ~/.vim/doc            (Unix)
This will make commands Voof, Vooflog, Voofexec, Voofhelp available in any
buffer.

Execute the :helptags command to install "voof.txt" as Vim help and to
generate help tags, see |add-local-help|: >
    :helptags $HOME/vimfiles/doc
    :helptags ~/.vim/doc

VOOF can also be run from any directory without installing anything, see
Overview -> QUICK DEMO.

NOTE: VOOF uses quickload mechanism, see |write-plugin-quickload|. The bulk of
the "voof.vim" script is sourced and "voof.py" is imported only after a Voof
command is executed for the first time.

NOTE: When "voof.vim" is sourced, its Python code adds script's directory to
sys.path and then imports "voof.py". This creates file "voof.pyc". Command
:Voofexec, when executing a Python script, creates file "voofScript.py" also
in the "voof.vim" directory.

NOTE: If is recommended that the following line be put in .vimrc when using
Voof outlining on a regular basis: >
    let g:voof_verify_oop = 1
This option turns on verification of outline data integrity after every
outline operation. It will alert to outline corruption, which is very likely
if there is a bug in outline operation. This verification is disabled by
default because it's rather expensive when the outline is large (>500
headlines).

==============================================================================
Options   [[[1o~
                                                 *voof_options*
==============================================================================
Vim Options   [[[2~

'foldmethod' for the buffer for which the command :Voof is executed should be
"marker" (:set fdm=marker). This, however, is not required to create an
outline or to use it. Outline operations do not rely on Vim folds, they use
start fold markers with levels. Other folding options, such as 'foldtext' can
be set according to personal preferences and could be filetype-specific.

'foldmarker' (local to window) is used by the Voof command to obtain the start
fold marker string. There is rarely a reason to change this option from
default, which is {{{,}}} .

<LocalLeader> is used to start many outline operations while in a Tree buffer.
By default, it's backslash. For example, \i inserts new node.  To change it to
another character, assign maplocalleader in .vimrc: >
     let maplocalleader=','

'scrolloff' should be 0 (default) or a small number (1 or 2). This global
option affects how the headline is positioned in the Body window after
selecting node in the Tree. For example, with scrolloff=1, the headline will
be on the 2nd window line in the Body window. A very large value can be
confusing when switching between Tree and Body windows.

Vim commands for creating and deleting folds are not very useful and are
potentially dangerous when typed accidentally. They can be disabled in .vimrc
as follows: >
     " Disable commands for creating and deleting folds.
     noremap zf <Nop>
     noremap zF <Nop>
     noremap zd <Nop>
     noremap zD <Nop>
     noremap zE <Nop>

Some color schemes (including default) use the same or similar background
colors for selected text (Visual), folded lines (Folded), and current line
(CursorLine) highlight groups. These highlight groups are used in Tree windows
and it's better if they are different from each other.

==============================================================================
VOOF Options   [[[2o~
These are VOOF-specific global variables that can be assigned in .vimrc.
Example: >
    let g:voof_tree_placement = "top"
    let g:voof_tree_height = 14

==============================================================================
Window positioning [[[3~

g:voof_tree_placement   ~
    Where Tree window is created: "left", "right", "top", "bottom"
    This is relative to the current window.
    Default: "left"

g:voof_tree_width   ~
    Initial Tree window width.
    Default: 30

g:voof_tree_height   ~
    Initial Tree window height.
    Default: 12

g:voof_log_placement   ~
    Where __PyLog__ window is created: "left", "right", "top", "bottom"
    This is far left/right/top/bottom.
    Default: "bottom"

g:voof_log_width   ~
    Initial __PyLog__ window width.
    Default: 30

g:voof_log_height   ~
    Initial __PyLog__ window height.
    Default: 12

==============================================================================
Tree/Body shuttle keys   [[[3~
                                                 *voof_shuttle_keys*
Since VOOF emulates a two-pane outliner, it's important to have keys that
shuttle between the two panes. By default, such keys are <Return> and <Tab>.
These keys are used in buffer-local mappings in Trees (Normal and Visual
modes) and in Bodies (Normal mode).

These are the only keys that get mapped in Body when the command :Voof is
executed.

Note that these keys have default meaning in Vim:
<Return> moves cursor down, which is not very useful since "j" does almost the
same thing.
<Tab>/CTRL-I in Normal mode goes to newer position in the jump list (opposite
of CTRL-O, see |CTRL-I|). It seems that Ctrl-Tab still works like default
<Tab>/CTRL-I, at least in GUI Vim, when <Tab> is mapped.

The following two settings allow to use keys or key combinations other than
<Return> and <Tab>.

g:voof_return_key   ~
    Key that selects node and, if the node is already selected, shuttles
    between Tree and Body windows.
    Default: "<Return>"

g:voof_tab_key   ~
    Key that shuttles between Tree and Body windows without selecting node.
    Default: "<Tab>"

Example, use Ctrl-Return, and Ctrl-Tab: >
    let g:voof_return_key = '<C-Return>'
    let g:voof_tab_key = '<C-Tab>'

==============================================================================
g:voof_verify_oop   [[[3~

g:voof_verify_oop   ~
    Verify outline after every outline operation.
    Default is 0 (disabled).
    Set to 1 to enable.

    It is recommended that this option be enabled when using Voof outlining on
    a regular basis. It will alert to outline corruption, which is very likely
    if there is a bug in outline operation. The downside is that there is a
    performance hit when the outline is large (>500 headlines).

==============================================================================
Customizing Tree and __PyLog__ buffers   [[[3~

When a Tree buffer is created, its 'filetype' is set to "vooftree"
When __PyLog__ buffer is created, its 'filetype' is set to "log".

This should allow user customization of these buffers (syntax, wrap/norwap,
list/nolist, etc.) via standard Vim configuration files: >
   $HOME/vimfiles/ftplugin/vooftree.vim
   $HOME/vimfiles/syntax/vooftree.vim
   $HOME/vimfiles/after/syntax/log.vim
   etc.

==============================================================================
Other Options   [[[3~
Most VOOF commands can be mapped to key shortcuts in .vimrc: >
    nnoremap <LocalLeader><LocalLeader> :Voof<CR>
    nnoremap <LocalLeader>n :Voofunl<CR>

To make Body headlines stand out, lines with fold markers can be highlighted.
Since I use .txt files for notes, I have the following line in .vimrc  >
    au BufWinEnter *.txt if &ft==#'text' | exe 'syn match ModeMsg /\V\.\*' . split(&fmr, ',')[0] . '\.\*/' | endif
This method is better than using syntax/txt.vim because it also works when a
nonstandard foldmarker is specified on file's modeline.

==============================================================================
# ALL MAPPINGS & COMMANDS #   [[[1x=  ~
                                                 *voof_map*
        MAIN COMMANDS~
:Voof               Create outline of the current buffer. |voof_Voof|
:Voofhelp           Open voof.txt as outline in a new tabpage. |voof_Voofhelp|
:Voofexec [vim|py]  Execute node or fold as [type] script. |voof_Voofexec|
:Vooflog            Create __PyLog__ buffer. |voof_Vooflog|

        BODY BUFFER MAPPINGS~

<Return>    (n) Select node under the cursor. If already selected,
                move cursor to Tree window. |voof_shuttle_keys|
<Tab>       (n) Move cursor to Tree window.

        TREE BUFFER MAPPINGS~

        OUTLINE NAVIGATION

<Return>  (n,v) Select node under the cursor. If already selected,
                move cursor to Body window.
<Tab>     (n,v) Move cursor to Body window.

<Up>      (n) Move cursor Up and select new node.
<Down>    (n) Move cursor Down and select new node.
<Right>   (n) Traverse node's tree down: move to first child and select it.
<Left>    (n) Traverse node's tree up: move to parent and select it.
              If the node is expanded, it is contracted first.

<LeftRelease> (n) Mouse left button click. Select node.
                  Expand/contract node if clicked outside of headline text.

<Space>   (n) Expand/contract node without selecting it.

zc, zo, zM, zR, zv, etc.
          These are standard Vim folding commands. They expand/contract nodes.

=         (n) Put cursor on currently selected node.
+         (n) Put cursor on startup node (node marked with '=' in Body
              headline).

x         (n) Go to next marked node (find headline marked with 'x').
X         (n) Go to previous marked node.

        OUTLINE OPERATIONS

i I a A         (n) Edit headline of node under the cursor.

<LocalLeader>i  (n) Insert new node after current node.
<LocalLeader>I  (n) Insert new node as child of current node.

<C-Up>
<LocalLeader>u  (n,v) Move node(s) Up.

<C-Down>
<LocalLeader>d  (n,v) Move node(s) Down.

<C-Left>
<<
<LocalLeader>l  (n,v) Move node(s) Left (promote).

<C-Right>
>>
<LocalLeader>r  (n,v) Move node(s) Right (demote).

Cut/Copy/Paste operations use Vim + register (system clipboard).
dd              (n,v) Cut node(s).
yy              (n,v) Copy node(s).
pp              (n)   Paste node(s) after current node.

<LocalLeader>m  (n,v) Mark node(s) -- add 'x' to Body headlines.
<LocalLeader>M  (n,v) Unmark node(s) -- remove 'x' from Body headlines.

<LocalLeader>=  (n) Mark node as startup node -- add '=' to Body headline and
                    remove '=' from all other headlines.

        VARIOUS
<F1>            (n) Open help file voof.txt as outline in a new tabpage.
                    Same as :Voofhelp.

<LocalLeader>e  (n) Execute node. Same as :Voofexec.


        SAVE/RESTORE TREE BUFFER FOLDING (Tree buffer only)~

:[range]VoofFoldingSave     Save Tree folding. |voof_VoofFoldingSave|

:[range]VoofFoldingRestore  Restore Tree folding. |voof_VoofFoldingRestore|

:VoofFoldingCleanup         Cleanup 'o' node marks: remove them from nodes
                            without children. |voof_VoofFoldingCleanup|

<LocalLeader>fs     (n) Save Tree folding for current node and all
                        descendant nodes. Same as :VoofFoldingSave.
<LocalLeader>fr     (n) Restore Tree folding for current node and all
                        descendant nodes. Same as :VoofFoldingRestore.
<LocalLeader>fas    (n) Save Tree folding for entire outline.
                        Same as :%VoofFoldingSave.
<LocalLeader>far    (n) Restore Tree folding for entire outline.
                        Same as :%VoofFoldingRestore.

        VARIOUS COMMANDS (Tree or Body buffer)~

:Voofunl            Display node's UNL (Uniform Node Locator). |voof_Voofunl|

:Voofgrep [pattern] Search Body buffer for pattern and display results
                    in the quickfix window as list of UNLs of nodes with
                    matches. |voof_Voofgrep|

There is a bunch of commented out commands in the "Commands" node of voof.vim.
They are useful only during VOOF development.


==============================================================================
OUTLINING (:Voof)   [[[1o~
==============================================================================
Create Outline   [[[2o~
                                                 *voof_Voof*
:Voof   This command creates outline of the current buffer and displays it in
        a new window with a scratch buffer called Tree buffer. The current
        buffer becomes a Body buffer. The following happens:

The current buffer (Body) is scanned for lines with start fold markers with
level numbers: {{{3, {{{1, etc. These lines, or headlines, are displayed
in the corresponding Tree buffer as an outline using an indent-based folding.
The level of each headline is set to the number after the fold marker.

NOTE 1: End fold markers with levels, }}}1, }}}3, etc. are ignored and should
not be used.
NOTE 2: Matching fold markers without level numbers, {{{ and }}}, are ignored
and are useful to fold small areas inside numbered folds, e.g. parts of
functions. The region between {{{ and }}} should not contain fold markers with
levels.

Tree buffers are named {bufname}_VOOF{bufnr} where {bufname} and {bufnr} are
buffer name and number of the corresponding Body buffer.

Each Tree buffer is displayed in separate window. A Tree buffer and its window
are configured to behave as the tree pane of a two-pane outliner. Each
headline in a Tree buffer is associated with a node of the corresponding Body.

"Node" is a Body buffer range that begins with headline (line with start fold
marker with level number) and ends before the next headline. The last node
ends with the last buffer line. The region from start of buffer to the first
headline (or end of buffer) is treated as a special node number 1 (it can have
zero lines).

When Body has 'foldmethod' set to "marker" (|fold-marker|), Body nodes are
also folds. This is recommended, but is not required: VOOF outlining does not
rely on folding, only on lines with start fold markers with levels.

When a headline is selected in Tree window (<Return>, <Up>, <Down>, <Left>,
<Right>), the corresponding node is displayed in Body window. Nodes can be
manipulated from Tree window: deleted, moved, promoted, demoted, marked, etc.
Of course, Body buffer can be edited directly as any other buffer with fold
markers.

The outline data and Tree buffer are updated when the cursor is moved to the
Tree buffer (on |BufEnter|). The actual update happens if the Body has been
modified since the last update (when Body's b:changedtick is different, see
|b:changedtick-variable|). This update is the bottleneck that limits the size
of outlines that can be worked with comfortably.

A Tree buffer is not modifiable and should never be edited directly. It has
many buffer-local mappings that are designed to navigate the outline and to
perform outline operations. Most of Vim standard Normal and Visual text change
commands are either disabled or remapped.

A Body buffer is just like a regular buffer. It has only two VOOF-specific,
buffer-local mappings: <Return> and <Tab> in Normal mode, which select current
node and/or cycle between Body and Tree. Other keys can be used instead of
Return and Tab by assigning variables g:voof_return_key and g:voof_tab_key in
vimrc (|voof_shuttle_keys|).

==============================================================================
About Fold Markers   [[[3~
The command :Voof does not create an outline of folds. It creates an outline
of start fold markers with level numbers. For best resutls, the Body should
have 'foldmethod' set to "marker". Then, nodes in the Tree buffer will also
represent Body folds.

The start fold marker string is obtained from window-local option 'foldmarker'
when outline is created with the command :Voof. For example, after >
    :set fmr=<<<,>>>
    :Voof
the outline will be created from lines with <<<1, <<<2, <<<3, etc.

'foldmarker' should not be changed while using an outline. If you change it,
make sure to recreate the outline: delete Tree buffer and execute the command
:Voof again.

VOOF scans only for start fold markers with level numbers. Fold markers
without level numbers and any end fold markers are ignored. This is not a
problem as long as the user follows the following rules. From author's
experience, these rules are very reasonable. They are similar to
recommendations given in Vim help, see |fold-marker|.

1) Use start fold markers with levels, <<<1, <<<2, etc. to start new
fold/node. These should correspond to important structures: parts and
chapters in a book, functions and classes in a code.

2) DO NOT USE END FOLD MARKERS WITH LEVELS: >>>1, >>>2, etc. They are
redundant and are hard to keep track of in a large outline.

3) Do use pairs of matching fold markers without level, <<< and >>>, to fold
small areas of text (a screenful), such as parts of functions. Just make sure
the area doesn't contain fold markers with levels.

Files that do have end fold markers with levels are ok for browsing with VOOF,
but outline operations will most definitely produce unintended results.
Consider the following structure: >
    node 0
        node 1   <<<1
            node 1.1 <<<2
        >>>1
    ? ? ? ?
    ? ? ? ?
        node 2   <<<1
        node 3   <<<1
Lines with ? are not part of any fold. But VOOF considers them part of node
1.1 and will move them accordingly when node 1.1 is moved. When node's level
is changed, only number after the start fold marker is updated.

==============================================================================
Special Node Marks   [[[3~
                                                 *voof_special_marks*
The following characters in Body headline immediately after the start fold
marker level number have special meaning. They are used by VOOF to indicate
node properties:
    'x'   Node is marked. This is like a checked checkbox.
    'o'   Node is opened (expanded). The corresponding Tree buffer fold will
          be opened when outline is created with the command :Voof. Obviously,
          this applies only to nodes with children.
    '='   Startup node. This node will be selected when outline is created
          with the command :Voof.

Various VOOF mappings and commands read and write these special marks.

Each mark is optional, but the order must be xo= . Examples, assuming that
foldmarker is set to <<<,>>> : >
    headline <<<1xo=  --node is marked, opened, startup node
    headline <<<1xo   --node is marked, opened
    headline <<<1o    --node is opened
    headline <<<1x=   --node is marked, startup node

    headline <<<1=xo  --node is startup node, 'x' and 'o' are ignored
    headline <<<1 xo= --all marks are ignored

==============================================================================
~~~===--- Tree Headline Text ---===~~~  "#//% /*[[[3*/ ~
The headline text as displayed in a Tree buffer is constructed from the
corresponding Body headline as follows:
  - Part of the Body headline before the first matching fold marker with level
    number is taken. If there is 'x' after level number (node is marked), 'x'
    is displayed in the second column of Tree buffer.
  - Trailing white space and line comment chars #"/*% are removed.
  - Leading and trailing white space is removed.
  - Leading and trailing filler chars -=~ are removed.
  - White space is trimmed again.

This is done by voofOutline() in voof.py .

==============================================================================
Selected Node   [[[3~
At any moment, one node is designated as selected. It is marked by = character
in the Tree buffer. This is sort of like "current position" in a true two-pane
outliner.

In contrast, "current node" here means node under the cursor. Current node may
or may not be selected.

A node is selected by pressing <Return> (Tree or Body, Normal mode), or by
selecting new node in Tree window with arrow keys or mouse left button click.

It is possible to automatically select a node on startup. A startup node has
character '=' in Body headline after the level number and after optional 'x'
and 'o' marks. Tree mapping  <LocalLeader>=  inserts '=' in current node's
Body headline and removes '=' marks from all other headlines. Next time, when
outline is created by the command :Voof, the node with '=' will be
automatically selected.

Related Tree mappings, Normal mode:
=         Put cursor on currently selected node.
+         Put cursor on startup node, that is node marked with '=' in Body
          headline, if any. This will also warn if there are several such
          nodes. Mnemonic: + is Shift-=


Note: it would be nice to have current headline highlighted in the Tree buffer
(as Leo does). Sadly, Vim does not allow to apply syntax highlighting to
folded lines--the Folded hi group overrides all other highlighting. The
current headline is easy to highlight, but it doesn't work for contracted
nodes: >
    :syn match Pmenu /^=.\{-}|\zs.*/
This code is commented out in Voof_TreeConfigure().

==============================================================================
Delete Outline   [[[2~
To delete VOOF outline for a particular Body buffer: unload, delete, or wipe
out the corresponding Tree buffer (:bun, :bd, :bw). Tree buffers are
configured to be wiped out when deleted or unloaded.

When a Tree is wiped out, the associated Body buffer becomes mostly as it was
before the outline creation: it loses buffer-local mappings and autocommands
created by the command :Voof. Outline data associated with this Body buffer
(Vim and Python dictionary items) are deleted.

When a Body buffer is unloaded, deleted or wiped out, the corresponding Tree
buffer is wiped out.

==============================================================================
Outline Navigation   [[[2o~
The following mappings are defined for Normal mode, except <Return> and <Tab>
in Tree buffers, where they work both in Normal and Visual modes.

<Return> In Body buffer: select current node and show it in Tree window.
         If current node is already selected, move cursor to Tree window.
         In Tree buffer: select current node and show it in Body window.
         If current node is already selected, move cursor to Body window.

         <Return> creates new window with Body or Tree in the current tabpage
         if there is none. Thus, hitting <Return> after ":tab split" will
         create tabpage with a new outline view.

<Tab>    If Body buffer, move cursor to window with the corresponding Tree
         buffer.
         If Tree buffer, move cursor to window with the corresponding Body
         buffer.
         
Note: All Voof commands look for a Tree or Body window in the current tabpage
only. If windows are split, previous window (^Wp) is used if possible.

Note: <Return> and <Tab> are the only keys mapped by VOOF in Bodies. Other
keys or key combinations can be used instead by defining "g:voof_return_key"
and "g:voof_tab_key". See |voof_shuttle_keys|.

All other mappings are for Tree buffers only.

<Up>      Move cursor Up and select new node.

<Down>    Move cursor Down and select new node.

<Right>   Traverse node's tree down: move to first child and select it

<Left>    Traverse node's tree up: move to parent and select it.
          If the node is expanded, it will be contracted first.

<LeftRelease> Mouse left button click. If the click is to the right or to the
              left of the headline text, select node and toggle its
              expanded/contracted state. If the click is on the headline text,
              just select node.

<Space>   Toggle node's expanded/contracted state without selecting it. Make
          node visible if it's hidden in a fold.

zc, zo, zM, zR, zv, etc.
          These are standard Vim folding commands. They expand/contract nodes.

=         Put cursor on currently selected node.
+         Put cursor on startup node (node marked with '=' in Body headline),
          if any. Warn if there are several such nodes.
          Mnemonic: + is Shift-=

x         Go to next marked node (find headline marked with 'x').
X         Go to previous marked node.


==============================================================================
:Voofunl   [[[3~
                                                 *voof_Voofunl*
:Voofunl
This command displays node's UNL: Uniform Node Locator. (The term is from Leo
outliner.) An UNL looks something like this: >
    Part 2 -> Chapter 4 -> Section 3 -> subsection 5

The UNL is also copied to the 'n' register for easy pasting.

When executed from a Body, the outline data and the Tree will be updated if
needed.

==============================================================================
:Voofgrep   [[[3~
                                                 *voof_Voofgrep*
:Voofgrep [pattern]
This command searches Body buffer for [pattern] and displays results in the
|quickfix| window as a list of UNLs of nodes with matches.

The whitespace around the pattern is ignored. \s or [ ] can be used to
indicate leading or trailing whitespace.

If pattern is not provided, word at cursor is used, as when starting search
with * or # .

The pattern is copied to the search register @/ so that n/N commands and
search highlight could be used.

The search is always performed in Body buffer, from top to bottom. If current
buffer is a Tree buffer, the cursor will first move to window with the
corresponding Body. If current buffer is a Body, the outline and the Tree will
be updated if needed.

The search itself is done with |search()|. According to docs, 'ignorecase',
'smartcase' and 'magic' are used.

The search stops after the first 1000 matches are found.

The results are displayed in the quickfix window  (|quickfix-window|) as a
list of UNLs of nodes with matches: >
    || Voofgrep \<findme\>
    || 5 matches
    test_outline.txt|4| n1:1  |top-of-file
    test_outline.txt|31| n10:2|3 -> 3.2 -> 3.2.1 -> 3.2.1.1
    test_outline.txt|52| n17:1|4 -> 4.1
    test_outline.txt|93| n30:1|5 -> BB -> BB.1

Numbers after the file name are:
    - Body line number of first match in this node
    - node number, that is node's Tree line number
    - number of matches in this node

NOTE: The readability of UNLs is much better when the -> separators are
highlighted. I have the following two lines in
 $HOME\vimfiles\after\syntax\qf.vim: >
    syn match Title / -> /
    syn match LineNr /| n\d\+:\d\+\s*|/

==============================================================================
Outline Operations   [[[2o~
Outline operations are performed using Tree buffer-local mappings, that is
they are always performed in a Tree buffer.

When appropriate, operations are automatically applied to trees, that is to
top level nodes and all their descendant nodes. E.g., moving a node, moves the
node and its descendants as a tree. The level numbers of the node and its
descendants are automatically adjusted according to node's new position in the
outline.

Most operations can be performed on a range of sibling nodes using Visual
mode. The range is checked for being a valid range: all top level nodes should
be at the same level.

Where the moved or inserted nodes will end up depends on the
expanded/contracted status of the node after which the nodes are inserted.
This should be obvious and replicates default behavior of Leo text outliner.

Most outline operations can modify the corresponding Body buffer. They are
disabled if the Body is 'nomodifiable' or 'readonly'. The exceptions are Copy
and some other commands that never modify the Body.

An outline operation can be undone with one undo command in the corresponding
Body buffer.

==============================================================================
Edit Headline   [[[3~
The only way to edit headline text is to edit the corresponding Body line.

While in a Tree buffer, Normal mode:

i I a A    Start editing headline under the cursor.
           The cursor is moved into Body window and placed on the first word
           character before the fold marker in Body headline. To find the
           first word char, pattern |/\<| is used.

Other common editing commands are disabled in Tree buffers.

==============================================================================
Insert New Node   [[[3~

<LocalLeader>i   Insert new node after current node.
<LocalLeader>I   Insert new node as child of current node.

These commands create new headline and puts cursor on the new headline in the
Body where it can be edited. Tree buffer, Normal mode only.


==============================================================================
Move/Copy/Cut/Paste Nodes   [[[3~

<C-Up>
<LocalLeader>u      Move node(s) up.

<C-Down>
<LocalLeader>d      Move node(s) down.

<C-Left>
<<
<LocalLeader>l      Move node(s) left (promote).

<C-Right>
>>
<LocalLeader>r      Move node(s) right (demote).

dd                  Cut node(s).

yy                  Copy node(s).

pp                  Paste node(s) after current node. Normal mode only.

With the exception of Paste, these Tree buffer mappings are available in
Normal and Visual modes. In Visual mode, the range is checked for being valid:
top level nodes in the range must be siblings.

These commands always apply to trees, that is to top level nodes and all their
descendant nodes, even when only part of a tree is selected.

Cut/Copy/Paste commands use Vim's + register, that is system clipboard. The
Paste command checks clipboard for being a valid VOOF outline or a range of
sibling outlines. The first line in the clipboard must have strart fold marker
with level number.

==============================================================================
Mark/Unmark Nodes   [[[3~
Marking node is like checking a checkbox. A node is marked/unmarked by
adding/removing 'x' in Body headline after the start fold marker level number
(|voof_special_marks|). The 'x' is also displayed in the Tree.

<LocalLeader>m     Normal mode: mark node under the cursor.
                   Visual mode: mark all nodes in the range.
                   'x' is inserted in Body headlines.

<LocalLeader>M     Normal mode: unmark node under the cursor.
                   Visual mode: unmark all nodes in the range.
                   'x' is removed from Body headlines.

The above commands apply to individual nodes, not trees.

To unmark all: ggVG<LocalLeader>M

Related Tree mappings, Normal mode:
x         Go to next marked node.
X         Go to previous marked node.

==============================================================================
Mark Node As Startup Node   [[[3~

<LocalLeader>=   Mark current node as startup node.
                 Tree buffer, Normal mode.

This command inserts '=' character in Body headline after the start fold
marker level number and after optional 'x' and 'o' marks
(|voof_special_marks|). The '=' mark is removed from all other Body headlines.
This mark affects only Voof startup: node marked with '=' is selected when
outline is created for the first time by the command :Voof.

Related Tree mappings, Normal mode:
+         Put cursor on the startup node, if any. Warn if there are several
          such nodes. Mnemonic: + is Shift-=

==============================================================================
Save/Restore Tree Folding   [[[3~
                                                 *voof_VoofFoldingSave*
                                                 *voof_VoofFoldingRestore*
                                                 *voof_VoofFoldingCleanup*
Opened/closed folds in a Tree buffer are equivalent to expanded/contracted
nodes. VOOF allows to save and restore Tree buffer folding. To do this, it
relies on special marks in Body headlines: character 'o' immediately after the
start fold marker level number and after optional 'x' (|voof_special_marks|).
The 'o' mark indicates that the fold is opened. Such folds are opened
automatically on startup.

The following commands execute only a Tree buffer. They read and write 'o'
marks in Body healdines.

:[range]VoofFoldingSave     Save Tree folding by writing 'o' marks in Body
                            headlines. If a range is supplied, this is done
                            for individual nodes in the range. Without a
                            range, this is done for current node and all
                            descendant nodes.

:[range]VoofFoldingRestore  Restore Tree folding according to 'o' marks in
                            Body headlines. If a range is supplied, this is
                            done for individual nodes in the range. Without a
                            range, this is done for current node and all
                            descendant nodes.

:VoofFoldingCleanup         Cleanup 'o' marks: remove them from nodes without
                            children. Such marks are redundant but harmless,
                            they don't do anything. This is done for the
                            entire outline, even if a range is supplied.

To save or restore folding for entire outline: >
    :%VoofFoldingSave
    :%VoofFoldingRestore

There as also the following Tree buffer mappings, Normal mode:

<LocalLeader>fs         Save Tree folding for current node and all descendant
                        nodes. Same as :VoofFoldingSave .

<LocalLeader>fr         Restore Tree folding for current node and all
                        descendant nodes. Same as :VoofFoldingRestore .

<LocalLeader>fas        Save Tree folding for entire outline.
                        Same as :%VoofFoldingSave .

<LocalLeader>far        Restore Tree folding for entire outline.
                        Same as :%VoofFoldingRestore .

Mnemonics for mappings:  Foldins Save/Restore, Folding All Save/Restore.


==============================================================================
EXECUTING NODES (:Voofexec)   [[[1~
                                                 *voof_Voofexec*
:Voofexec [type]  Execute text in the current node and descendant nodes or
                  in the current fold and subfolds as [type] script.
                  Supported types are: "vim", "python" or "py".
                  In Tree buffers, :Voofexec is mapped to <LocalLeader>e .

The following happens when the command :Voofexec is executed:

1) The type of script is determined.

    :Voofexec           Without an argument, the type of script is set to
                        buffer 'filetype': "python" if filetype is "python",
                        "vim" if filetype is "vim", etc. When executed from a
                        Tree (also with <LocalLeader>e), filetype of the
                        corresponding Body is used.

    :Voofexec vim       Execute as "vim" script.

    :Voofexec python
    :Voofexec py        Execute as "python" script.

    :Voofexec whatever  Execute as "whatever" script.

    If script type is neither "vim" nor "python", the command aborts. It
    should be possible to add support for other script types.

2) The text of script is obtained.

    a) If current buffer is a Tree buffer, the script text is set to that of
       the current node (including headline) and all descendant nodes. The
       actual folding in the corresponding Body buffer does not matter and
       fold markers without levels are ignored.

    b) If current buffer is a regular, non-Tree buffer, the script text is set
       to that of the current fold, including all subfolds. This obviously
       makes sense only if 'foldmethod' is "marker". If 'foldmethod' is not
       "marker", the command aborts and the script is not executed.

3) The script is executed according to its type.

    a) A "vim" script is executed by copying text into a register and
       executing that register inside try/catch/endtry block.

    b) A "python" script is executed by first writing text to file
       "voofScript.py" in the "voof.vim" directory.
       The file is then executed using execfile() inside try/except block.
       See http://docs.python.org/library/functions.html#execfile .
       The following Python names are predefined: vim, VOOF, voof.
       The first line of "voofScript.py" specifies encoding as per
       http://www.python.org/dev/peps/pep-0263/ . Encoding is obtained from
       Body's 'fenc' or, if it's empty, from 'enc'. 

==============================================================================
sample Vim scripts   [[[2~
Scripts in the following subnodes can be executed with >
    :Voofe vim

"---node 1---[[[3o~
echo 'in node 1'

" section [[[
echo 'inside section in node 1'
" ]]]

"---node 1.1---[[[4o~
echo 'in node 1.1'

"---node 1.1.1---[[[5~
echo 'in node 1.1.1'

"=============================================================================
sample Python scripts   [[[2~
Scripts in the following subnodes can be executed with >
    :Voofe py

#---node 1---[[[3o~
print '   in node 1'

print 'buffer number:', vim.eval('bufnr("")')
print 'VOOF.buffers.keys():', VOOF.buffers.keys()
print 'voof.voofOutline() docstring:', voof.voofOutline.__doc__
import os
print 'current working dir:', os.getcwd()

# section [[[
print '   inside section in node 1'
# ]]]

#---node 1.1---[[[4o~
print '   in node 1.1'

#---node 1.1.1---[[[5~
print '   in node 1.1.1'

#=============================================================================
Known Problems   [[[2~

1) Vim script code executed this way cannot use |line-continuation|.

2) When Voofexec executes a Vim script with Python code and a Python error
occurs, Python traceback is not printed. However, Python traceback is printed
to the PyLog buffer if it is enabled. Example in the next fold can be executed
with ":Voofe vim". >
    " Vim script with Python error [[[
    echo 'start of vim script'
    py print bogus_name
    py print 'py after error'
    echo 'the end'
    " ]]]

3) As the example above illustrates, Vim script is not terminated when an
error occurs in the Python code.

==============================================================================
__PyLog__ BUFFER (:Vooflog)   [[[1~
                                                 *voof_Vooflog*
:Vooflog   This command creates scratch buffer __PyLog__ and redirects
           Python stdout and stderr to that buffer.

Subsequent Python print statements and error messages are appended to the
__PyLog__ buffer instead of being printed on Vim command line.

PyLog windows in all tabpages are scrolled automatically when something is
printed to the PyLog buffer. If a tabpage has several PyLog windows, only the
first one is scrolled. If the current tabpage has no PyLog windows, the
Vooflog command can be used to create one.

To restore original stdout and stdin (that is Vim command line): unload,
delete, or wipeout the __PyLog__ buffer (:bun, :bd, :bw).
NOTE: the __PyLog__ buffer is configured to be wiped out when unloaded or
deleted.

The filetype of the PyLog buffer is set to "log". Some syntax highlighting is
added automatically to highlight Python error messages and common VOOF
messages.

When Python attemps to print a unicode string, e.g. >
    :py print u'ascii test'
    :py print u'\u042D \u042E \u042F \u2248 \u2260'
the string is encoded using the value of Vim option 'encoding' at the time
when the __PyLog__ buffer was created.


==============================================================================
Known Problems:   [[[2~
1) All output lines appear in the __PyLog__ buffer simultaneously after the
script is finished, not in real time. Example (executable with :Voofe py):
### demo Python code [[[
import time, datetime
print datetime.datetime.now()
time.sleep(5)
print datetime.datetime.now()
### ]]]

2) __PyLog__ is not usable when in the Ex mode, that is after 'Q' or 'gQ'.
The lines in the __PyLog__ buffer will appear after the Ex mode is exited.

3) In versions before 1.7 there was problem with the output of help(), which
apparently uses Lib/pydoc.py, which does something strange to output trailing
\n. Steps to reproduce:
    1. Open new instance of Vim.
    2. Vooflog
    3. :py help(help)
    4. Wipe out __PyLog__ buffer to restore sys.stdout.
    5. :py help(help)
       An error occurs: '\n' is printed to the nonexisting log buffer.
The culprit is in Lib/pydoc.py:
    help = Helper(sys.stdin, sys.stdout)
The current workaround is to delete pydoc from sys.modules when changing stdin
and stdout.

==============================================================================
Implementation notes   [[[1~
                                                 *voof_notes*
==============================================================================
Why VOOF uses Python   [[[2~
The main reason VOOF uses Python is because some critical code is much faster
in Python than in Vim script.

Python scans buffer for fold markers >10 times faster than a similar Vim
script code. A demo code is given below. To test: select lines, copy into a
register, and execute that register while in any buffer with a large number of
fold markers, or in any large buffer.

Results with "calendar_outline.txt": >
    3.2MB, 56527 lines, 4160 headlines;
    Vim 7.2, Python 2.5, Win2k; Intel Pentium 4 Mobile, 1.6 GHz.

    Vim method 1: 1.48 sec
    Vim method 2: 0.14 sec
    Python:       0.09 sec

Vim method 2 is fast, but it's inconvenient to use because it requires cursor
to be in the Body buffer.

"""""""""""""""DEMO CODE START""""""""""""""""""""""""""""""""""""""""
" Get lines with fold marker followed by level number. This is the bare
" minimum that must be done to create an outline.

""""" Vim method 1
func! Voof_VimTest1()
    let headlines = []
    let allLines = getline(1,'$')
    for line in allLines
        if stridx(line, '{{{')==-1 "}}}
            continue
        endif
        if match(line, '{{{\d\+')!=-1 " }}}
            call add(headlines, line)
        endif
    endfor
    return len(headlines)
endfunc

""""" Vim method 2
func! Voof_VimTest2()
    let headlines = []
    g/{{{\d\+/ call add(headlines, getline('.'))     "}}}
    return len(headlines)
endfunc

""""" Python code, similar to Vim method 1
python << EOF
def Voof_PyTest():
    import vim
    import re
    re_marker = re.compile(r'{{{\d+')   #}}}
    headlines = []
    allLines = vim.current.buffer[:]
    for line in allLines:
        if not '{{{' in line: continue  #}}}
        if re_marker.search(line):
            headlines.append(line)
    vim.command('let nodes=%s' %len(headlines))
EOF

""""" timing
let start = reltime()
let nodes = Voof_VimTest1()
echo 'Vim method 1: ' . reltimestr(reltime(start)) . 'sec; '. nodes . ' nodes'

let start = reltime()
let nodes = Voof_VimTest2()
echo 'Vim method 2: ' . reltimestr(reltime(start)) . 'sec; '. nodes . ' nodes'

let start = reltime()
py Voof_PyTest()
echo 'Python:       ' . reltimestr(reltime(start)) . 'sec; '. nodes . ' nodes'
"""""""""""""""DEMO CODE END""""""""""""""""""""""""""""""""""""""""""


In addition, Python's FOR loop is >30 times faster then Vim's. In the demo
code below the Python function is >60 times faster.

""""""" Vim FOR loop versus Python FOR loop """"""""""
func! Time_VimForLoop()
    let aList = range(1000000)
    for i in aList
        " pass
    endfor
endfunc

python << EOF
def Time_PyForLoop():
    aList =     range(1000000)
    for i in aList:
        pass
EOF

""" 9.76 sec """
let start = reltime()
call Time_VimForLoop()
echo 'Vim:    ' . reltimestr(reltime(start))

""" 0.15 sec """
let start = reltime()
py Time_PyForLoop()
echo 'Python: ' . reltimestr(reltime(start))
""""""""""""""""""""""""""""""""""""""""""""""""""""""

Thus, Python code should be much faster when handling large lists.

==============================================================================
Separate Trees or Single Tree   [[[2~
A single Tree buffer could be used to display outlines of many files. Tlist
does that. This makes sense when working with several related files. Also,
having a single Tree would be more like Leo.

VOOF creates new Tree buffer for every new outline. This is simpler. It is
more appropriate for text notes, when outline files are likely to be
unrelated. Searching headlines is easier.

==============================================================================
When to wipe out Tree buffer   [[[2~
A Tree buffer should be wiped out and the corresponding VOOF data deleted
after:

1) Body is wiped out. Tree has no reason to exist.
2) Body is deleted. Body buffer-local mappings are lost.
3) Body is unloaded or deleted. When Body is loaded again, its b:changedtick
   is different.
4) Tree is unloaded. All content is lost, Tree reverts to blank buffer.
5) Tree is deleted. As above, plus buffer local mappings are lost.

This is accomplished via BufUnload autocommands for Tree and Body.
BufUnload is also triggered on BufDelete and BufWipeout.

Also, when a buffer is unloaded but still exists, that is after :bunload and
:bdelete, there is potential for big trouble when trying to modify the buffer
via Python--see next node.

There are several fail-safe measures that ensure that nothing damaging will
happen if BufUnload autocommands are not triggered, as after "noa bun", "noa
bd", "noa bw". Tree and Body buffers are always checked for being loaded
(bufloaded()) during most Voof commands.

Functions Voof_ToBody() and Voof_ToTree(), which are called when selecting
nodes and before every outline operation, will detect if the Body or Tree
buffer is no longer loaded and will perform cleanup.

The b:changedtick check (see "Checking Bodies for ticks") also will prevent
potential troubles after improper unloading of Body with "noa bun!", etc.
This is because b:changedtick changes after unloading a buffer and loading it
again.

When Tree or Body local mappings and syntax are lost after "noa bd", it is
possible to restore them by executing the command :Voof from the Body buffer. 

The PyLog buffer should also be wiped out when unloaded or deleted. There is a
check that ensures that PyLog is loaded before printing to it.

==============================================================================
unloaded buffer + python == trouble   [[[2~
Bad things happen when attempting to modify an unloaded buffer via Python
vim.buffer object. (This might be a Vim bug.) Example:
    - Create two buffers: buf1 and buf2. They can be new, no-file buffers.
    - With cursor in buf2
      :py buf2=vim.current.buffer
    - Buffer 2 can now be modified via Python:
      :py buf2[0]="xxxxxxxxx"
    - Unload buffer 2
      :bun!
      Buffer 1 is the current buffer.
    - Try writing to buffer 2, which is not loaded
      :py buf2[0]="yyyyy"
    - Buffer 1 is modified instead of buffer 2, and the change cannot be undone!
      Buffer 2 is no longer unloaded, so subsequent writes to it via buf2
      happen correctly.

VOOF's BufUnload autocommands ensure that Tree, Body, and PyLog buffers are
never unloaded when they are being written to. Buffers can become unloaded
when they are closed improperly with "noa bun" or "noa bd" or when something
goes wrong with autocommands. There are fail-safe checks that make sure that
the buffer is loaded (bufloaded()) before it is modified via Python.

==============================================================================
Checking Bodies for ticks   [[[2~
Tree buffer and associated outline data are updated on entering Tree via
BufEnter autocommand. To perform update only when the Body has changed since
the last update, Body's b:changedtick is used as shown in the docs. The
problem is that, for some reason,  b:changedtick cannot be read with
getbufvar(), so it's not accessible from Tree on BufEnter. The workaround is
to use Body's BufLeave autocommand to save Body's b:changedtick. So the entire
update scheme is:
    - on Body BufLeave save Body's b:changedtick as "tick"
    - on Tree BufEnter compare "tick_" to "tick"
    - if different, do outline update and set "tick_" to "tick"

The outline must be up to date when the cursor is in the Tree buffer. If it's
not, the consequences could be unpleasant. Performing outline operations will
cause data corruption.

Outline update can fail when something goes wrong with autocommands, e.g.,
when some plugin messes with eventignore. Or, the Body file can be modified by
an external application while cursor is in Tree.

Fortunately, most Voof commands involve a visit from Tree to Body or vice
versa, so we can compare "tick_" directly to Body's "b:changedtick". If they
are different, the Tree buffer is wiped out and associated data are cleaned
up. Such check is performed during:
    - selecting node from Tree or Body
    - Voofgrep command initiated from Tree
    - during every outline operation, before modifying buffers
The function that does this check is Voof_BodyCheckTicks().

These checks can be tested by modifying Body and then moving to Tree with
"noau wincmd w" or after "set ei=BufLeave", etc.

Another precaution is that outline update (voof.voofUpdate()) is always done
inside try/finally/endtry. This ensures that "tick_" will not be set to "tick"
when an error occurs during the update.

==============================================================================
TODO   [[[2x~

==============================================================================
May be   [[[3~
outline scripting API
    typical tasks:
        convert to html, etc.
        extract/delete/mark nodes with pattern or tag
    Python only?
        separate .py module
        node iterators as in Leo: for p in c.allNodes_iter(), etc.
        vim.command('com! VoofBlah :py print "Blah!"')
    speed is not important; brute force total update and redraw


VoofToUnl [UNL]. If no UNL, uses visual selection. UNLs are too fragile.

Some kind of scheme to allow external scripts to create/modify Tree-local
mappings.  Need hooks in Voof_TreeMap(). How?

Use t:voof_bodywnr and t:voof_treewnr to keep track of previous Body and Tree
windows, set these on WinLeave. This would be more robust than current
reliance of the previous window (winnr('#')) when both Tree and Body are split
and there are perhaps windows with other buffers as well.

==============================================================================
Don't want to [[[3~
derived files
    @file, like Leo's @nosent; don't need no fancy directives
    :Voofsave writes @file trees to external files
    need something like @language for this to be truly useful
    derived files are silly, this is what project managers are for

Something like Leo's script buttons. Not feasible.

Voofexec should determine script type from current syntax. A must if @language
is implemented.

Foolproof against changing "foldmarker". Not a real problem.

Use special buffer do display Voofgrep results.

Command to search node and subnodes:
    Voofsearch {pattern} will search for
    \%>{nodeStart-1}l\%<{nodeEnd+1}l{pattern}
    default is to search node and subnodes
    options:
        n --search current node only
        h --search headlines only
        b --search bodies only
    or, require a range and search in range
    search headlines, finds anywhere
    .*\zs{pattern}\ze\&.*{{{    "}}}
    or (doesnt find after marker)
    {pattern}\V\ze\.\*{{{       "}}}
This is unreliable--pattern becomes invalid after lines are inserted/deleted.
Voofgrep already shows if particular node has a match.

Mark nodes with {pattern} -- could be option to Voofsearch.
Better done via outline scripting API.

Sort children. Outline scripting API.

Tree: undo does Body undo and updates outline

Tree: write writes Body (:w increments b:changedtick)

==============================================================================
CHANGELOG   [[[2o~

v1.9, 2009-12-19   [[[3x~
It's now possible to save and restore Tree buffer folding. This feature uses
special node marks 'o' in Body headlines. See |voof_VoofFoldingSave|.

New Tree mapping: + (Shift-=) finds startup node, if any, that is  node marked
with '=' in Body headline. Warns if there are several such nodes.

Command "Voofrun" was renamed "Voofexec".

Tree mapping for Execute Script was changed to "<LocalLeader>e" from
"<LocalLeader>r", which was in conflict with mapping for "Move Right".

Executing Python code via Voofexec: source code encoding is now specified on
the first line of script file as per http://www.python.org/dev/peps/pep-0263/.
Encoding is obtained from Body's 'fenc' or, if it's empty, from 'enc'. 

Fixed bug in Voofexec: unsupported script type argument was ignored if
buffer's filetype was a supported script type. More informative message if
script type is unsupported.

Improved how the command Edit Headline (iIaA) positions cursor in Body
headline: "\<" is used instead of "\w" to find the first word char. This works
better with unicode.

"g:voof_tree_hight" and "g:voof_log_hight" were renamed "g:voof_tree_height"
and "g:voof_log_height" respectively.


v1.8, 2009-09-18   [[[3~
Bug in Normal mode mappings: nasty errors when attempting to use mapping with
a count, which is not supported, e.g., 3<Return>.
Fix: made all mappings start with ":<C-u>" to clear command line before
calling a function.

Added highlighting of warning and error messages.

Added fancy highlighting of Voofunl output: different highlights for headlines
and separators.

Correction in docs: <Tab>/CTRL-I is Vim default key for going forward in the
jumps list.

Distribution now follows Vim directory structure: there are /plugin and /doc
folders. Simplified Voofhelp accordingly: if voof.vim is in dir a/b, voof.txt
is assumed to be in a/doc.

Changed license to WTFPL, version 2.

v1.7, 2009-08-31   [[[3~
Checks that previously checked that Body or Tree buffer exists now check if
the buffer is loaded (bufloaded()). This is needed because bad things happen
when writing to an unloaded buffer via Python's vim.buffer.
See "Implementation notes -> unloaded buffer + python == trouble"

When killing Trees and PyLog do "bwipeout" instead of "bwipeout!" -- it's
sufficient and safer.

Adjusted how new Tree window is opened: previous window (^wp) is used if it
shows a Tree buffer.

PyLog:
Added fail-safe check that ensures PyLog buffer is loaded before being written
to. This can be tested by unloading PyLog with "noa bun" or "noa bd" and then
printing to it: py print "something".
Added workaround for a glitch with the output of help().
Made voof_logbnr variable script-local.

v1.6, 2009-08-23   [[[3~
Added checks to prevent data corruption when outline update fails for any
reason. When these checks fail, the Tree buffer is wiped out and outline data
are cleaned up. These checks can be tested as follows:
    - Create outline with the Voof command.
    - Delete some lines in Body buffer.
    - Move to Tree buffer with
      :noa wincmd w
    - Tree update did not happen and outline data are out of sync with the
      Body. In previous versions, performing outline operation at this stage
      would cause data corruption.
    - Select new node or try outline operation. Voof will issue error message,
      wipe out Tree buffer, and perform clean up.
Another way to test these checks is to modify Body file with an external
application while cursor is in the Tree window.
There is more details in "Implementation notes -> Checking Bodies for ticks".

Added some other foolproofing measures.

Improved automatic scrolling of PyLog buffer. Both previous (^wp) and current
window numbers are preserved in tabpages where PyLog is scrolled. Previously,
only current window number was preserved.

Fixed some bugs. Streamlined some code.

v1.5, 2009-08-15   [[[3~
New commands: Voofgrep, Voofunl.

Fixed blunder in "Move Down" outline operation that could cause outline
corruption. To find node after which to move, the cursor must be put on the
last node of the tree. That was done in Visual mode, but not in Normal mode.

<Return> and <Tab> in Tree buffers now also work in Visual mode.

Changed behavior of <Tab>: move cursor to Body window if current window is
Tree and vice versa. Previous behavior (cycle through all Body and Tree
windows) was less useful and inconsistent with <Return> behavior.

Added checks for Body foldmethod. If it's not "marker":
 - folds in Body are not collapsed (zMzv) after node selection in Tree and
   after outline operations;
 - Voofrun will refuse to run when executed while in Body buffer.

Made Tree buffers and PyLog buffer unlisted.

If possible, :Voofhelp command will open voof.txt via "tab help voof.txt"
command, so that tags will be active.

Made help tags start with "voof_".

Edited "Why VOOF uses Python": it turns out there is a fast, pure Vim method
to scan for headlines, but it's much less convenient than the Python way: >
    let headlines=[]
    g/{{{\d\+/ call add(headlines, getline('.'))       "}}}

code improvements [[[4~
The way "eventignore" was used to temporarily disable autocommands was unsafe.
"eventignore" is no longer set anywhere. "noautocmd" is used instead:
|autocmd-disable|.

Modified voof.voofUpdate() (formally treeUpdate) to work from any buffer as
long as the Tree is "ma". Voof_TreeBufEnter() now calls voof.voofUpdate()
directly.  Voof_BodyUpdateTree() updates Tree while in Body without moving to
Tree. This is extremely useful--can now use outline data while in Body.

Optimization in voof.voofOutline() parser function: >
    if not marker in line: continue
This makes sense because search with marker regexp is 3-4 times slower than
the above membership test, and in a typical outline most lines don't have
markers. Timing voof.voofUpdate() in Voof_TreeBufEnter(),
"calendar_outline.txt" update when headlines unchanged:
0.17 sec instead of 0.24 sec.

Changed Vim data variables voof_bodies, voof_trees, etc. from global to
script-local. Command VoofPrintData prints these for debugging purposes.
Should external scripts need to read these, a function that returns these
could be provided.

voof.computeSnLn() uses bisect--should be faster than previous naive code.

Changed <f-args> in Voofrun to <q-args> -- simpler.

PyLog code is, hopefully, near the state of perfection: when something goes
wrong, the exception info is displayed no matter what.

voof.oopMarkSelected() -- don't remove just one =, strip all consecutive

Voof_GetLines() uses winsaveview()/winrestview() to prevent scrolling after
zc/zo.

Use setreg() to restore registers exactly as shown in help.
Doing "let @z=z_old" is not reliable enough--register mode can change.


v1.4, 2009-07-12   [[[3~
New Tree navigation commands (Normal mode):
 x   Go to next marked node (mnemonic: find headline marked with 'x').
 X   Go to previous marked node.

"Unmark Node" operation now removes all consecutive 'x' chars from Body
headline instead of just one. This eliminates confusion when a bunch of 'x' is
present after start fold marker level number. For the same reason, "Mark Node
as Selected" (<LocalLeader>=) now strips 'x' chars after removed '=' char.

Bug: When Body starts with a headline, click on the first line in Tree (path
info line) doesn't select first node.
Fix: in Python code of Voof_TreeSelect() replaced
 nodeEnd =  VOOF.nodes[body][lnum]-1
   with
 nodeEnd =  VOOF.nodes[body][lnum]-1 or 1

Fixed errors in LogBufferClass write() method, printing messages when log
buffer doesn't exist.

Bug: Select more than one lines in Tree and press i/I/A/a. An error in
Voof_OopEdit() occurs.
Fix: Mapped i/I/A/a keys only for Normal mode with nnoremap. They were
mistakenly mapped with noremap.

A message is now printed when an outline operation is aborted because Body
buffer is readonly or nomodifiable.

Replaced most Python regions in voof.vim with voof.py functions.

Renamed some Python functions:
voof_WhatEver() means it's Python code for Voof_WhatEver() Vim function.

Voof_FoldLines() renamed Voof_GetLines().
Voof_FoldRun() renamed Voof_Run().

Various edits and additions in voof.txt.


v1.3, 2009-06-06   [[[3~
New: start fold marker string is obtained from Vim option 'foldmarker' when
the Voof command is run. Each Body buffer can have its own start fold marker.

Replaced Body's BufDelete autocommand with BufUnload autocommand. Tree buffer
is now wiped out when its Body is unloaded, deleted or wiped out. Corrected
Body and Tree BufUnload au functions: use "nested" and "noautocmd".

Added * to chars being stripped during headline construction to allow /**/
around fold markers. Better syntax highlight for commented headlines in Tree.

Changed how Tree buffer name is constructed: {bufname}_VOOF{bufnr} instead of
VOOF_{bufname}_{bufnr}.

When checking if current buffer is a Tree, instead of checking buffer name, do
has_key(g:voof_trees, bufnr('')).

When eventignore is set, save and restore original eventignore instead of
doing "set eventignore=" .

Annoyance: Moving Tree window to top/bottom (^W K/J) maximizes window height.
Fix: Don't set "winfixheight" when creating Tree window. I don't understand why
this happens. There is no such problem with "winfixwidth".

Got rid of Voof_ErrorMsg() and Voof_InfoMsg().

Expanded help file.

v1.2, 2009-05-30   [[[3~
Bug: after outline operation cursor may be on the last line of range instead
of first (if Visual and there is only one root node).
Fix: tweaked Voof_OopShowTree().

Re-wrote Voof_TreeToggleFold() to handle: no fold at cursor; cursor hidden in
fold.

Allow outline operation Copy when Body is noma or ro.

v1.1, 2009-05-26   [[[3~
Bug fix involving nomodifiable and readonly buffers.
Outline operations now silently abort if Body is noma or ro.

v1.0, 2009-05-25   [[[3~
Initial release.

==============================================================================
modelines   [[[1~
 vim:fdm=marker:fmr=[[[,]]]:ft=help:ai:et:noma:ro:
 vim:foldtext=getline(v\:foldstart).'...'.(v\:foldend-v\:foldstart):
